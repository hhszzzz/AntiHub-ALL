"接口","作用","实际起什么作用/对接Backend或者前端干了什么"
"GET /api/user/me","获取当前用户信息","校验 Authorization: Bearer sk-xxx；从插件 users 表读出当前用户信息（隐藏完整 api_key）；AntiHub-Backend 的 PluginAPIService.get_user_info 会代理调用（对应后端 /api/plugin-api/preference GET）"
"POST /api/users","创建用户（管理员）","需要管理员 Bearer(ADMIN_API_KEY)；在插件 users 表创建用户并生成 sk-xxx；AntiHub-Backend 注册流程会用 PLUGIN_API_ADMIN_KEY 调它来“自动创建并绑定插件用户”(PluginAPIService.create_plugin_user/auto_create_and_bind_plugin_user)"
"GET /api/users","获取用户列表（管理员）","需要管理员 Bearer；用于插件侧排障/运营查看 users 全量；后端当前无常规前端入口直连"
"POST /api/users/{user_id}/regenerate-key","重置用户 API Key（管理员）","需要管理员 Bearer；为指定插件用户重新生成 sk-xxx；主要给插件侧密钥轮换/救火用（后端未默认暴露）"
"PUT /api/users/{user_id}/status","启用/禁用用户（管理员）","需要管理员 Bearer；更新 users.status（0/1）；用于封禁某个插件用户（后端未默认暴露）"
"PUT /api/users/{user_id}/preference","设置 Cookie 优先级","用户本人或管理员可改；更新 users.prefer_shared（0=专属优先/1=共享优先）；AntiHub-Backend 的 /api/plugin-api/preference PUT 会转发到这里"
"DELETE /api/users/{user_id}","删除用户（管理员）","需要管理员 Bearer；删除插件用户及其关联数据（具体级联看 service 实现）；后端未默认暴露"
"POST /api/oauth/authorize","生成 Antigravity OAuth 授权链接","校验 Bearer sk-xxx；生成 Google OAuth URL 并把 state 绑定 user_id/is_shared；后端 /api/plugin-api/oauth/authorize 代理给前端用于“打开授权页面”"
"GET /api/oauth/callback","处理 OAuth 回调（Google 重定向）","无需插件 API key；Google 授权后重定向到这里，插件用 code+state 换 token 并落库 accounts；返回 HTML 成功/失败页（给浏览器看的）"
"POST /api/oauth/callback/manual","手动提交 OAuth 回调 URL","校验 Bearer sk-xxx；用于用户把完整 callback_url 粘贴上来走同样的换 token/落库逻辑；后端 /api/plugin-api/oauth/callback 会转发到这里（前端 submitOAuthCallback 用的就是后端这条）"
"POST /api/accounts/import","用 refresh_token 导入账号","校验 Bearer sk-xxx；无需走浏览器 OAuth，直接用 refresh_token 换 access_token 并落库 accounts（并初始化/更新配额等）；前端通过后端 /api/plugin-api/accounts/import 调用"
"GET /api/accounts","获取账号列表","校验 Bearer sk-xxx；查询 accounts（脱敏，不返回 token）；前端账号管理页通过后端 /api/plugin-api/accounts 调用"
"GET /api/accounts/{cookie_id}","获取单个账号","校验 Bearer sk-xxx；按 cookie_id 查 accounts（权限：本人/管理员），返回脱敏字段；前端通过后端 /api/plugin-api/accounts/{cookieId} 调用"
"GET /api/accounts/{cookie_id}/credentials","导出账号凭证（敏感）","校验 Bearer sk-xxx；返回 access_token/refresh_token/expires_at 等敏感字段，给前端“复制凭证为 JSON”；通过后端 /api/plugin-api/accounts/{cookieId}/credentials 调用"
"POST /api/accounts/{cookie_id}/refresh","手动刷新账号","校验 Bearer sk-xxx；强制 refresh access_token，并尝试更新 project_id_0（必要时 onboardUser）；失败 invalid_grant 会标记 need_refresh；前端通过后端 /api/plugin-api/accounts/{cookieId}/refresh 调用"
"GET /api/accounts/{cookie_id}/projects","获取 Project ID 列表（Code Assist）","校验 Bearer sk-xxx；确保 token 有效后调用上游 loadCodeAssist/onboardUser 推断可用 project_id；前端通过后端 /api/plugin-api/accounts/{cookieId}/projects 用于项目选择/展示"
"PUT /api/accounts/{cookie_id}/project-id","设置自定义 Project ID","校验 Bearer sk-xxx；写入 accounts.project_id_0（后续上游请求会优先用它）；前端通过后端 /api/plugin-api/accounts/{cookieId}/project-id 调用"
"GET /api/accounts/{cookie_id}/detail","获取账号详情（邮箱/订阅层）","校验 Bearer sk-xxx；必要时实时补邮箱、用 loadCodeAssist 推断订阅层；前端通过后端 /api/plugin-api/accounts/{cookieId}/detail 调用"
"PUT /api/accounts/{cookie_id}/status","启用/禁用账号","校验 Bearer sk-xxx；更新 accounts.status；若是共享账号会同步增减用户共享配额池（user_quotas）；前端通过后端 /api/plugin-api/accounts/{cookieId}/status 调用"
"PUT /api/accounts/{cookie_id}/name","修改账号名称","校验 Bearer sk-xxx；更新 accounts.name；前端通过后端 /api/plugin-api/accounts/{cookieId}/name 调用"
"DELETE /api/accounts/{cookie_id}","删除账号","校验 Bearer sk-xxx；删除 accounts；若是共享账号会把该账号对应模型配额从用户共享配额池扣除；前端通过后端 /api/plugin-api/accounts/{cookieId} (DELETE) 调用"
"PUT /api/accounts/{cookie_id}/type","切换账号类型（专属/共享）","校验 Bearer sk-xxx；修改 accounts.is_shared，并按该账号现有 model_quotas 自动增减用户共享配额池；后端有 /api/plugin-api/accounts/{cookieId}/type 可转发（前端未必已接 UI）"
"GET /api/accounts/{cookie_id}/quotas","获取账号配额（并刷新落库）","校验 Bearer sk-xxx；调用上游 modelsUrl 实时拉取模型配额/重置时间并更新 model_quotas；前端通过后端 /api/plugin-api/accounts/{cookieId}/quotas 调用"
"PUT /api/accounts/{cookie_id}/quotas/{model_name}/status","手动启用/禁用某账号某模型","校验 Bearer sk-xxx；更新 model_quotas.status（用于把某些模型从可选列表踢掉/恢复）；前端通过后端 /api/plugin-api/accounts/{cookieId}/quotas/{modelName}/status 调用"
"GET /api/quotas/low?threshold=0.1","获取低配额模型（管理员）","需要管理员 Bearer；用于监控哪些模型剩余配额接近阈值；后端/前端当前未默认暴露"
"GET /api/quotas/user","获取当前用户聚合配额池","校验 Bearer sk-xxx；返回 user_quotas（共享配额池聚合）；前端通过后端 /api/plugin-api/quotas/user 调用"
"GET /api/quotas/shared-pool","获取共享池聚合配额","校验 Bearer sk-xxx；聚合所有共享账号配额，并会自动刷新 reset_time 已过期的共享账号配额；后端有对应转发（/api/plugin-api/quotas/shared-pool），前端目前未看到直连调用"
"GET /api/quotas/consumption?limit=&start_date=&end_date=","获取用户配额消耗流水","校验 Bearer sk-xxx；查询 quota_consumption_logs（可按日期/数量筛）；前端通过后端 /api/plugin-api/quotas/consumption 调用"
"GET /api/quotas/consumption/stats/{model_name}","获取某模型消耗统计","校验 Bearer sk-xxx；按 model_name 聚合消耗/请求统计；用于图表/排障（前端未看到直连调用）"
"GET /v1/models","OpenAI 兼容模型列表","校验 Bearer sk-xxx；支持 X-Account-Type/X-Api-Type 选择 antigravity/kiro/qwen，未指定则合并三方模型；后端 PluginAPIService.get_models 及后端 /v1/models 会把它当上游"
"POST /v1/chat/completions","OpenAI 兼容聊天补全","校验 Bearer sk-xxx；按 X-Account-Type/X-Api-Type 或 model 推断路由到 antigravity/kiro/qwen，上游请求/刷 token/流式转发在插件完成；AntiHub-Backend 的 /v1/chat/completions 会鉴权/记日志后转发到插件作为上游"
"POST /v1beta/models/{model}:generateContent","Gemini v1beta 图片生成（非流式）","校验 Bearer sk-xxx；把 contents+generationConfig.imageConfig 转成上游图片请求并返回 JSON；后端 /api/plugin-api/v1beta/models/{model}:generateContent 会代理到这里"
"POST /v1beta/models/{model}:streamGenerateContent","Gemini v1beta 图片生成（名为流式但实际返回 JSON）","校验 Bearer sk-xxx；与 generateContent 走同一处理逻辑；用于兼容客户端调用 :streamGenerateContent"
"POST /api/kiro/oauth/authorize","生成 Kiro Social OAuth 链接","校验 Bearer sk-xxx；生成 Kiro 登录 URL，自动生成 machineid，并把 OAuth state（含 user_id/is_shared/bearer_token）写 Redis；前端通过后端 /api/kiro/oauth/authorize 调用"
"GET /api/kiro/oauth/status/{state}","轮询 Kiro OAuth 状态","无需插件 API key；从 Redis 读取 state 状态，返回 pending/completed/error；前端通过后端 /api/kiro/oauth/status/{state} 轮询"
"POST /api/kiro/oauth/callback","处理 Kiro 回调（kiro://）","无需插件 API key；解析 callback_url 或 code/state，读取 Redis stateInfo，换 token、抓取 usage limits 并落库 kiro_accounts；桌面端 AntiHook/后端 /api/kiro/oauth/callback 用来转发深链回调"
"POST /api/kiro/accounts","手动创建/导入 Kiro 账号","校验 Bearer sk-xxx；用 refresh_token(+IdC client_id/secret) 刷新并验证 token，抓取 usage limits 后落库 kiro_accounts；前端通过后端 /api/kiro/accounts 调用"
"GET /api/kiro/accounts","获取 Kiro 账号列表","校验 Bearer sk-xxx；查询 kiro_accounts（脱敏）；前端通过后端 /api/kiro/accounts 调用"
"GET /api/kiro/accounts/{account_id}","获取单个 Kiro 账号","校验 Bearer sk-xxx；权限：本人/管理员；返回脱敏信息；前端通过后端 /api/kiro/accounts/{accountId} 调用"
"GET /api/kiro/accounts/{account_id}/credentials","导出 Kiro 凭证（敏感）","校验 Bearer sk-xxx；返回 refresh/access_token、machineid、profile_arn、client_secret 等，用于前端“复制凭证 JSON”；经后端 /api/kiro/accounts/{accountId}/credentials 转发"
"PUT /api/kiro/accounts/{account_id}/status","启用/禁用 Kiro 账号","校验 Bearer sk-xxx；更新 kiro_accounts.status；前端通过后端 /api/kiro/accounts/{accountId}/status 调用"
"PUT /api/kiro/accounts/{account_id}/name","修改 Kiro 账号名称","校验 Bearer sk-xxx；更新 kiro_accounts.account_name；前端通过后端 /api/kiro/accounts/{accountId}/name 调用"
"GET /api/kiro/accounts/{account_id}/balance","刷新余额/使用量","校验 Bearer sk-xxx；必要时先 refresh token，再调用 usage limits 更新 current_usage/reset_date/bonus/free_trial 并计算可用额度；前端通过后端 /api/kiro/accounts/{accountId}/balance 调用"
"DELETE /api/kiro/accounts/{account_id}","删除 Kiro 账号","校验 Bearer sk-xxx；删除 kiro_accounts；前端通过后端 /api/kiro/accounts/{accountId} (DELETE) 调用"
"GET /api/kiro/accounts/{account_id}/consumption","获取 Kiro 消费记录","校验 Bearer sk-xxx；从 kiro_consumption_logs 拉用户消费并按账号过滤，可按日期筛；前端通过后端 /api/kiro/accounts/{accountId}/consumption 调用"
"GET /api/kiro/consumption/stats","获取用户总消费统计","校验 Bearer sk-xxx；聚合当前用户所有 Kiro 账号的消费统计；前端通过后端 /api/kiro/consumption/stats 调用"
"GET /api/kiro/admin/subscription-models","获取订阅层可用模型配置（管理员）","需要管理员 Bearer；查询订阅层->模型白名单规则（用于限制不同 subscription 可用模型）；前端通过后端 /api/kiro/admin/subscription-models（需管理员）调用"
"PUT /api/kiro/admin/subscription-models","设置订阅层可用模型配置（管理员）","需要管理员 Bearer；upsert 订阅层->模型白名单（model_ids=null 表示删除回默认）；前端通过后端 /api/kiro/admin/subscription-models（需管理员）调用"
"GET /v1/kiro/models","Kiro OpenAI 兼容模型列表","校验 Bearer sk-xxx；返回 Kiro 可用模型；AntiHub-Backend 的 KiroService.get_models 会代理它（用于后端 /v1/models 或 Kiro 专用入口）"
"POST /v1/kiro/chat/completions","Kiro OpenAI 兼容聊天补全","校验 Bearer sk-xxx；Kiro 专用 chat.completions，支持 tools/tool_calls + conversationState；AntiHub-Backend 的 KiroService.chat_completions(_stream) 会代理它作为上游"
"POST /api/qwen/oauth/authorize","生成 Qwen Device Flow 登录链接","校验 Bearer sk-xxx；发起 Qwen Device Flow，写 Redis state，并后台轮询换 token 后落库 qwen_accounts；前端通过后端 /api/qwen/oauth/authorize 调用（Redis 不可用会 503）"
"GET /api/qwen/oauth/status/{state}","轮询 Qwen OAuth 状态","无需插件 API key；从 Redis 取 state 状态返回 pending/completed/failed（不返回敏感 token）；前端通过后端 /api/qwen/oauth/status/{state} 轮询"
"POST /api/qwen/accounts/import","导入 QwenCli JSON","校验 Bearer sk-xxx；解析 credential_json/credential，抽取 access_token/refresh_token/resource_url/expires_at 等并落库 qwen_accounts；前端通过后端 /api/qwen/accounts/import 调用"
"GET /api/qwen/accounts","获取 Qwen 账号列表","校验 Bearer sk-xxx；查询 qwen_accounts（脱敏）；前端通过后端 /api/qwen/accounts 调用"
"GET /api/qwen/accounts/{account_id}","获取单个 Qwen 账号","校验 Bearer sk-xxx；权限：本人/管理员；返回脱敏信息；前端通过后端 /api/qwen/accounts/{accountId} 调用"
"GET /api/qwen/accounts/{account_id}/credentials","导出 Qwen 凭证（敏感）","校验 Bearer sk-xxx；返回 access_token/refresh_token/resource_url/expires_at 等，用于前端“复制凭证 JSON”；经后端 /api/qwen/accounts/{accountId}/credentials 转发"
"PUT /api/qwen/accounts/{account_id}/status","启用/禁用 Qwen 账号","校验 Bearer sk-xxx；更新 qwen_accounts.status；前端通过后端 /api/qwen/accounts/{accountId}/status 调用"
"PUT /api/qwen/accounts/{account_id}/name","修改 Qwen 账号名称","校验 Bearer sk-xxx；更新 qwen_accounts.account_name；前端通过后端 /api/qwen/accounts/{accountId}/name 调用"
"DELETE /api/qwen/accounts/{account_id}","删除 Qwen 账号","校验 Bearer sk-xxx；删除 qwen_accounts；前端通过后端 /api/qwen/accounts/{accountId} (DELETE) 调用"
"GET /api/qwen/admin/accounts","管理员查看全部 Qwen 账号","需要管理员 Bearer；列出所有可用 Qwen 账号用于排障；后端未默认暴露"
